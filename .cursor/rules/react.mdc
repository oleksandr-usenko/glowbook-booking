---
description:
globs:
alwaysApply: true
---
---

description: React best practices and patterns for modern web applications
globs: **/*.tsx
---

# React Best Practices

## Component Structure

- Use functional components over class components
- Keep components small and focused
- Extract reusable logic into custom hooks
- Use composition over inheritance
- Implement proper prop types with TypeScript
- Split large components into smaller, focused ones

## Hooks

- Follow the Rules of Hooks
- Use custom hooks for reusable and business logic
- Keep hooks focused and simple
- Use appropriate dependency arrays in useEffect
- Implement cleanup in useEffect when needed
- Avoid nested hooks
- Avoid conditional hooks

## State Management

- Use useState for local component state
- Use Context API for shared state
- Keep state as close to where it's used as possible
- Avoid prop drilling through proper state management
- Use state management libraries only when necessary

## Performance

- Implement proper memoization (useMemo, useCallback)
- Use React.memo for expensive components
- Avoid unnecessary re-renders
- Implement proper lazy loading
- Use proper key props in lists
- Profile and optimize render performance

## Forms

- Use `react-hook-form` for managing forms in all cases
- Use controlled components for form inputs
- Implement proper form validation
- Handle form submission states properly
- Show appropriate loading and error states
- Implement proper accessibility for forms

## Error Handling

- Implement Error Boundaries
- Handle async errors properly
- Show user-friendly error messages
- Implement proper fallback UI
- Log errors appropriately
- Handle edge cases gracefully

## Internationalisation

- Avoid hardcoding any user-facing text in components
- Use a dedicated i18n library for managing translations (located in `packages/i18n` folder)
- Store translations strings in separate JSON files or resource files, one per language
- Use translation keys and namespaces for organization
- Translation keys and namespaces will be organized based on their position in the UI (e.g. grouped by routes, then by sections/purpose)
- Support pluralization and variable interpolation in translations
- All translations must be in sentence case
- Handle date, time, and number formatting according to locale en-US

## Testing

- Write unit tests for components
- Implement integration tests for complex flows
- Use React Testing Library
- Test user interactions not implementations
- Test error scenarios
- Do not mock any API calls, use msw instead

## Accessibility

- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Test with screen readers
- Handle focus management
- Provide proper alt text for images

### File naming conventions

- **Components**: Use PascalCase (e.g. `MyComponent.tsx`).
- **Hooks**: Use camelCase prefixed with `use` (e.g., `useMyHook.ts`).
- **Contexts**: Use PascalCase suffixed with `Context` (e.g., `MyContext.tsx`).
- **Services/Utils**: Use camelCase (e.g., `apiService.ts`, `stringUtils.ts`).
- **Styles**: Do not create separate files for styles, just use Tailwind.

## Code organization

- Group related components together
- Use proper file naming conventions
- Implement proper directory structure
- Keep styles close to components
- Use proper imports/exports
- Document complex component logic

## Code Syntax

- Do not use React.ReactNode to type children in components. Use `PropsWithChildren` instead

## Conditional className

- **Always use `cn` for conditional classes**: When applying classes conditionally, use the `cn` utility function
- **Import `cn`**: Import `cn` at the top of the file
- **Use object syntax**: Prefer object syntax for conditional classes: `cn({ className: condition })`
- **Avoid string concatenation**: Never use template literals or string concatenation for conditional classes
- **Avoid ternary operators**: Never use ternary operators like `condition ? "class" : ""` for conditional classes

### Correct Examples

```tsx
// Object syntax (preferred)
<div className={cn({ hidden: isHidden })} />
<div className={cn({ "text-red-500": hasError, "text-green-500": !hasError })} />

// Multiple conditions
<div className={cn("base-class", { "hidden": isHidden, "opacity-50": isDisabled })} />
```

### Incorrect Examples

```tsx
// ❌ String concatenation
<div className={isHidden ? "hidden" : ""} />

// ❌ Template literals
<div className={`base-class ${isHidden ? "hidden" : ""}`} />

// ❌ String concatenation with &&
<div className={isHidden && "hidden"} />
```
